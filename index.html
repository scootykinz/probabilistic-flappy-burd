<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probabilistic Flappy Burd - THRML Inspired</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(255, 107, 107, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            background: linear-gradient(180deg, #0a1128 0%, #1a1a2e 100%);
            cursor: pointer;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffd700;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        
        #hamburger {
            background: rgba(255, 107, 107, 0.8);
            border: 2px solid #ffd700;
            color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 24px;
            transition: all 0.3s;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #hamburger:hover {
            background: rgba(255, 107, 107, 1);
            transform: scale(1.1);
        }
        
        #controlsMenu {
            position: absolute;
            top: 60px;
            right: 0;
            background: rgba(26, 26, 46, 0.95);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        #controlsMenu.open {
            display: flex;
        }
        
        .control-btn {
            background: rgba(255, 107, 107, 0.8);
            border: 2px solid #ffd700;
            color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background: rgba(255, 107, 107, 1);
            transform: scale(1.05);
        }
        
        .control-btn.active {
            background: rgba(100, 255, 100, 0.8);
            border-color: #00ff00;
        }
        
        .control-btn.active:hover {
            background: rgba(100, 255, 100, 1);
        }
        
        .quantum-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid #ffd700;
            animation: pulse 2s infinite;
        }
        
        .quantum-btn.active {
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(102, 126, 234, 0.5); }
            50% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.8); }
        }
        
        .temp-control {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #ffd700;
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
        }
        
        .temp-slider {
            width: 100%;
            margin-top: 5px;
        }
        
        #footer {
            position: absolute;
            bottom: 50px;
            left: 20px;
            right: 20px;
            color: #88ccff;
            font-size: 11px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 10;
            text-align: center;
        }
        
        #footer a {
            color: #ffd700;
            text-decoration: none;
        }
        
        #footer a:hover {
            text-decoration: underline;
        }
        
        #energyVisualizer {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 400px;
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #ffd700;
            border-radius: 5px;
            padding: 5px;
            z-index: 5;
            display: flex;
            flex-direction: column-reverse;
            gap: 2px;
        }
        
        .energy-bar {
            flex: 1;
            border-radius: 2px;
            transition: background-color 0.2s;
        }
        
        #optimalPath {
            display: none;
        }
        
        .ghost-bird {
            opacity: 0.6;
        }
        
        #instructions {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #88ccff;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 10;
            display: none;
        }
        
        #thrmlInfo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            color: #88ccff;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 10;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="info">Score: 0</div>
        <div id="controls">
            <div id="hamburger" onclick="toggleMenu()">‚ò∞</div>
            <div id="controlsMenu">
                <button class="control-btn quantum-btn" id="quantumHardwareBtn" onclick="toggleQuantumHardware()">
                    üîÆ Quantum HW: OFF
                </button>
                <button class="control-btn active" id="quantumBtn" onclick="toggleQuantumMode()">
                    üåå Quantum: ON
                </button>
                <button class="control-btn" id="multiBurdBtn" onclick="toggleMultiBurd()">
                    üê¶ Multi-Burd: OFF
                </button>
                <button class="control-btn" id="autoplayBtn" onclick="toggleAutoplay()">
                    ü§ñ Autoplay: OFF
                </button>
                <button class="control-btn" id="optimalPathBtn" onclick="toggleOptimalPath()" style="display:none;">
                    üëª Show Optimal
                </button>
                <div class="temp-control">
                    <div>üå°Ô∏è Temperature: <span id="tempValue">1.0</span></div>
                    <input type="range" class="temp-slider" id="tempSlider" 
                           min="0.5" max="2.0" step="0.1" value="1.0" 
                           onchange="updateTemperature(this.value)">
                </div>
            </div>
        </div>
        <div id="energyVisualizer"></div>
        <div id="instructions">Click anywhere to Flap!</div>
        <div id="footer">
            Made for <a href="https://partiful.com/e/82h0A4OKfmNJPG3T81qR" target="_blank">THRML-HACK Hackathon</a> | 
            By <a href="https://x.com/scootykins" target="_blank">@scootykins</a> | 
            <a href="https://github.com/scootykinz/probabilistic-flappy-burd" target="_blank">GitHub</a>
        </div>
        <div id="thrmlInfo">
            üî¨ THRML Energy-Based Sampling | Toggle Quantum HW for Real THRML! | 
            <a href="https://docs.thrml.ai" target="_blank" style="color: #ffd700;">THRML Docs</a>
        </div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        /**
         * Toggle hamburger menu
         */
        function toggleMenu() {
            const menu = document.getElementById('controlsMenu');
            menu.classList.toggle('open');
        }
        
        // Game state
        let score = 0;
        let gameRunning = false;
        let gameStarted = false;
        let birdY = 100;
        let birdVelocity = 0;
        const gravity = 0.25;
        const flapPower = -6.5;
        const maxFallSpeed = 8;
        const birdX = 150;
        const birdSize = 30;
        
        // New features
        let quantumMode = true;    // Toggle quantum visualization
        let autoplayMode = false;  // AI autoplay
        let gameOverTime = 0;      // Track when game ended
        const GAME_OVER_DELAY = 2000; // 2 seconds before showing game over
        let aiDebugInfo = { targetY: 0, action: 'none' }; // Debug info
        let temperature = 1.0;     // Boltzmann temperature for sampling
        let quantumHardwareMode = false; // Try to use real THRML backend
        let hardwareConnecting = false;
        let multiBurdMode = false; // Show multiple birds at once
        let multiBurds = [];       // Array of {y, v, trajectory} for each burd
        let showOptimalPath = false; // Show the best path after game over
        let optimalPathData = null;  // Stores the optimal trajectory
        
        // Pipe configuration
        const pipeWidth = 80;
        const pipeGap = 220;
        let pipes = [];
        let pipeSpeed = 2.5;
        let frameCount = 0;
        let gracePeriod = 180;
        
        // THRML-INSPIRED PROBABILISTIC SAMPLING
        // This uses energy-based modeling concepts from THRML
        let probabilityCloud = [];  // Stores sampled future trajectories
        const NUM_SAMPLES = 30;     // Number of trajectories to sample
        const PREDICTION_STEPS = 20; // How many frames to predict ahead
        
        /**
         * THRML-Inspired Energy Function
         * Lower energy = more likely state
         * Based on Energy-Based Models (EBMs) from THRML documentation
         */
        function calculateEnergy(y, velocity, pipes, timeStep) {
            let energy = 0;
            
            // Gravity term: lower positions have lower energy when falling
            if (velocity > 0) {
                energy += (y / canvas.height) * 0.5;  // Falling is natural
            } else {
                energy -= (y / canvas.height) * 0.3;  // Going up costs energy
            }
            
            // Boundary penalties (high energy near floor/ceiling)
            if (y < 50) energy += 3.0;
            if (y > canvas.height - 50) energy += 3.0;
            
            // Pipe collision penalties
            pipes.forEach(pipe => {
                const pipeAtTime = pipe.x - (pipeSpeed * timeStep);
                if (Math.abs(pipeAtTime - birdX) < pipeWidth + birdSize) {
                    // Bird is at pipe X position
                    if (y < pipe.topHeight || y > pipe.bottomY) {
                        energy += 10.0;  // HUGE penalty for collision
                    } else {
                        energy -= 1.0;   // Reward for threading the gap
                    }
                }
            });
            
            return energy;
        }
        
        /**
         * Gibbs Sampling (inspired by THRML's block Gibbs sampling)
         * Sample from probability distribution proportional to exp(-energy)
         */
        function sampleTrajectory(startY, startVelocity, pipes, temp = null) {
            const samplingTemp = temp || temperature; // Use global temperature if not specified
            const trajectory = [{y: startY, v: startVelocity}];
            let currentY = startY;
            let currentV = startVelocity;
            
            for (let t = 0; t < PREDICTION_STEPS; t++) {
                // Sample multiple possible next states
                const candidates = [];
                
                // Option 1: Flap (add upward velocity)
                let flapY = currentY;
                let flapV = -6.5;
                flapV += gravity;
                flapV = Math.min(flapV, maxFallSpeed);
                flapY += flapV;
                const flapEnergy = calculateEnergy(flapY, flapV, pipes, t);
                candidates.push({y: flapY, v: flapV, energy: flapEnergy});
                
                // Option 2: Don't flap (let gravity work)
                let fallY = currentY;
                let fallV = currentV + gravity;
                fallV = Math.min(fallV, maxFallSpeed);
                fallY += fallV;
                const fallEnergy = calculateEnergy(fallY, fallV, pipes, t);
                candidates.push({y: fallY, v: fallV, energy: fallEnergy});
                
                // Option 3: Small random perturbation (exploration)
                let perturbY = currentY;
                let perturbV = currentV + (Math.random() - 0.5) * 2;
                perturbV += gravity;
                perturbV = Math.min(perturbV, maxFallSpeed);
                perturbY += perturbV;
                const perturbEnergy = calculateEnergy(perturbY, perturbV, pipes, t);
                candidates.push({y: perturbY, v: perturbV, energy: perturbEnergy});
                
                // Boltzmann distribution: P(state) ‚àù exp(-energy / temperature)
                // Lower energy = higher probability
                const weights = candidates.map(c => Math.exp(-c.energy / samplingTemp));
                const totalWeight = weights.reduce((a, b) => a + b, 0);
                const probabilities = weights.map(w => w / totalWeight);
                
                // Sample according to probabilities
                const rand = Math.random();
                let cumulative = 0;
                let selected = candidates[0];
                for (let i = 0; i < probabilities.length; i++) {
                    cumulative += probabilities[i];
                    if (rand < cumulative) {
                        selected = candidates[i];
                        break;
                    }
                }
                
                // Clamp to screen bounds
                selected.y = Math.max(0, Math.min(canvas.height, selected.y));
                
                currentY = selected.y;
                currentV = selected.v;
                trajectory.push({y: currentY, v: currentV});
            }
            
            return trajectory;
        }
        
        /**
         * Sample multiple trajectories (like THRML's sample_states function)
         * Uses real THRML backend if quantum hardware mode is enabled
         */
        async function sampleProbabilityCloud() {
            // Try quantum hardware backend first
            if (quantumHardwareMode) {
                try {
                    const response = await fetch('http://localhost:5001/predict', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            birdY: birdY,
                            velocity: birdVelocity,
                            pipes: pipes.map(p => ({
                                x: p.x,
                                topHeight: p.topHeight,
                                bottomY: p.bottomY
                            }))
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        // Convert backend trajectories to our format
                        probabilityCloud = data.trajectories.map(traj => 
                            traj.map(y => ({ y: y, v: 0 }))
                        );
                        return; // Success! Use THRML samples
                    }
                } catch (error) {
                    console.log('Quantum hardware unavailable, using JS fallback');
                    // Fall through to JavaScript sampling
                }
            }
            
            // JavaScript fallback sampling
            probabilityCloud = [];
            for (let i = 0; i < NUM_SAMPLES; i++) {
                // Temperature variation adds diversity
                const tempVariation = temperature * (0.8 + Math.random() * 0.4);
                const traj = sampleTrajectory(birdY, birdVelocity, pipes, tempVariation);
                probabilityCloud.push(traj);
            }
        }
        
        /**
         * Toggle quantum hardware mode - tries to connect to THRML Python backend
         */
        async function toggleQuantumHardware() {
            const btn = document.getElementById('quantumHardwareBtn');
            
            if (quantumHardwareMode) {
                // Turn off
                quantumHardwareMode = false;
                btn.classList.remove('active');
                btn.textContent = 'üîÆ Quantum HW: OFF';
                return;
            }
            
            // Try to connect!
            hardwareConnecting = true;
            btn.textContent = '‚ö° Connecting...';
            btn.disabled = true;
            
            try {
                // Try to ping the Python backend
                const response = await fetch('http://localhost:5001/health', {
                    method: 'GET',
                    mode: 'cors'
                });
                
                if (response.ok) {
                    // SUCCESS! Backend is running!
                    quantumHardwareMode = true;
                    btn.classList.add('active');
                    btn.textContent = 'üîÆ Quantum HW: ON';
                    alert('üéâ Connected to THRML Backend!\n\nNow using real thermodynamic sampling from the Python server!');
                } else {
                    throw new Error('Backend not responding');
                }
            } catch (error) {
                // Failed - show funny error message
                quantumHardwareMode = false;
                btn.classList.remove('active');
                btn.textContent = 'üîÆ Quantum HW: OFF';
                
                alert('‚ö†Ô∏è Quantum Computer Connection Failed\n\n' +
                      'The thermodynamic computer is currently:\n' +
                      '‚Ä¢ Taking a nap üò¥\n' +
                      '‚Ä¢ Out of quantum fuel ‚öõÔ∏è\n' +
                      '‚Ä¢ Or the Python backend isn\'t running\n\n' +
                      'Falling back to JavaScript energy-based sampling!\n\n' +
                      '(To enable: Run `python thrml_server.py` in the repo)');
            }
            
            hardwareConnecting = false;
            btn.disabled = false;
        }
        
        /**
         * Update temperature parameter for Boltzmann sampling
         */
        function updateTemperature(value) {
            temperature = parseFloat(value);
            document.getElementById('tempValue').textContent = temperature.toFixed(1);
            
            // Re-sample if game is running
            if (gameRunning && quantumMode) {
                sampleProbabilityCloud();
            }
        }
        
        /**
         * Toggle quantum visualization mode
         */
        function toggleQuantumMode() {
            quantumMode = !quantumMode;
            const btn = document.getElementById('quantumBtn');
            if (quantumMode) {
                btn.classList.add('active');
                btn.textContent = 'üåå Quantum: ON';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üåå Quantum: OFF';
            }
            // Auto-close menu on mobile/smaller screens
            if (window.innerWidth < 600) {
                toggleMenu();
            }
        }
        
        /**
         * Toggle multi-burd mode
         */
        function toggleMultiBurd() {
            multiBurdMode = !multiBurdMode;
            const btn = document.getElementById('multiBurdBtn');
            if (multiBurdMode) {
                btn.classList.add('active');
                btn.textContent = 'üê¶ Multi-Burd: ON';
                initializeMultiBurds();
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üê¶ Multi-Burd: OFF';
                multiBurds = [];
            }
            if (window.innerWidth < 600) {
                toggleMenu();
            }
        }
        
        /**
         * Toggle optimal path display
         */
        function toggleOptimalPath() {
            showOptimalPath = !showOptimalPath;
            const btn = document.getElementById('optimalPathBtn');
            if (showOptimalPath) {
                btn.classList.add('active');
                btn.textContent = 'üëª Hiding Optimal';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üëª Show Optimal';
            }
        }
        
        /**
         * Initialize multiple burds from probability distribution
         */
        function initializeMultiBurds() {
            multiBurds = [];
            const numBurds = 10;
            
            for (let i = 0; i < numBurds; i++) {
                multiBurds.push({
                    y: birdY,
                    v: birdVelocity,
                    trajectory: probabilityCloud[i] || []
                });
            }
        }
        
        /**
         * Update multi-burds each frame
         */
        function updateMultiBurds() {
            if (!multiBurdMode || !gameRunning) return;
            
            // Re-sample trajectories periodically
            if (frameCount % 10 === 0 && probabilityCloud.length > 0) {
                multiBurds.forEach((burd, i) => {
                    if (probabilityCloud[i]) {
                        burd.trajectory = probabilityCloud[i];
                    }
                });
            }
            
            // Update each burd's position from its trajectory
            multiBurds.forEach((burd, i) => {
                if (burd.trajectory && burd.trajectory.length > 0) {
                    // Follow the sampled trajectory
                    const trajIndex = Math.min(frameCount % 20, burd.trajectory.length - 1);
                    if (burd.trajectory[trajIndex]) {
                        burd.y = burd.trajectory[trajIndex].y;
                        burd.v = burd.trajectory[trajIndex].v || 0;
                    }
                }
            });
        }
        
        /**
         * Calculate optimal (lowest energy) path through pipes
         */
        function calculateOptimalPath() {
            if (!pipes || pipes.length === 0) return null;
            
            const pathLength = 200;
            const optimalPath = [];
            let currentY = birdY;
            let currentV = 0;
            
            for (let step = 0; step < pathLength; step++) {
                // Find next pipe
                const futureX = birdX + (step * pipeSpeed);
                const relevantPipe = pipes.find(p => 
                    p.x > futureX - 50 && p.x < futureX + 100
                );
                
                let targetY;
                if (relevantPipe) {
                    // Aim for center of gap
                    targetY = (relevantPipe.topHeight + relevantPipe.bottomY) / 2;
                } else {
                    // Maintain middle height
                    targetY = canvas.height * 0.45;
                }
                
                // Move toward target with physics
                if (currentY > targetY + 20) {
                    currentV = -6; // Flap
                } else {
                    currentV += gravity;
                    currentV = Math.min(currentV, maxFallSpeed);
                }
                
                currentY += currentV;
                currentY = Math.max(50, Math.min(canvas.height - 50, currentY));
                
                optimalPath.push({ x: birdX + step * 2, y: currentY });
            }
            
            return optimalPath;
        }
        
        /**
         * Toggle autoplay mode
         */
        function toggleAutoplay() {
            autoplayMode = !autoplayMode;
            const btn = document.getElementById('autoplayBtn');
            if (autoplayMode) {
                btn.classList.add('active');
                btn.textContent = 'ü§ñ Autoplay: ON';
                if (!gameStarted) {
                    startGame();
                }
            } else {
                btn.classList.remove('active');
                btn.textContent = 'ü§ñ Autoplay: OFF';
            }
            // Auto-close menu on mobile/smaller screens
            if (window.innerWidth < 600) {
                toggleMenu();
            }
        }
        
        /**
         * AI Autoplay - uses probability cloud to make decisions!
         */
        function aiDecideFlap() {
            if (!autoplayMode || !gameRunning) return false;
            
            // CRITICAL: Don't flap during grace period when there are no pipes!
            if (frameCount <= gracePeriod) {
                // Just maintain a good height before pipes start
                if (birdY > canvas.height * 0.6 && birdVelocity > 4) {
                    aiDebugInfo = { targetY: canvas.height * 0.6, action: 'grace-maintain' };
                    return true;
                }
                if (birdY > canvas.height - 100) {
                    aiDebugInfo = { targetY: canvas.height - 100, action: 'grace-floor' };
                    return true;
                }
                aiDebugInfo = { targetY: canvas.height * 0.6, action: 'grace-wait' };
                return false;
            }
            
            // Find the next pipe we need to navigate
            const nextPipe = pipes.find(p => p.x + pipeWidth > birdX);
            
            if (!nextPipe) {
                // No pipes yet or all pipes passed - maintain center-low height
                const targetHeight = canvas.height * 0.55; // Stay lower!
                aiDebugInfo.targetY = targetHeight;
                
                if (birdY > targetHeight + 50 && birdVelocity > 2) {
                    aiDebugInfo.action = 'no-pipe-maintain';
                    return true;
                }
                
                if (birdY > canvas.height - 100) {
                    aiDebugInfo.action = 'no-pipe-floor';
                    return true;
                }
                
                aiDebugInfo.action = 'no-pipe-coast';
                return false;
            }
            
            // We have a pipe to navigate
            const pipeDistance = nextPipe.x - birdX;
            const gapTop = nextPipe.topHeight;
            const gapBottom = nextPipe.bottomY;
            const gapCenter = (gapTop + gapBottom) / 2;
            const gapSize = gapBottom - gapTop;
            
            // KEY FIX: Aim for BELOW center - let gravity do the work!
            // This prevents the upward trending issue
            const idealY = gapCenter + 20;  // Aim BELOW center, not above!
            aiDebugInfo.targetY = idealY;
            
            // Decision logic based on distance to pipe
            if (pipeDistance > 150) {
                // We're far away - just don't hit the floor
                
                // Only flap if we're getting dangerously low
                if (birdY > idealY + 60) {
                    aiDebugInfo.action = 'far-too-low';
                    return true;
                }
                
                // Floor emergency
                if (birdY > canvas.height - 120) {
                    aiDebugInfo.action = 'far-floor-danger';
                    return true;
                }
                
                // Otherwise let gravity work - don't flap!
                aiDebugInfo.action = 'far-coast';
                return false;
                
            } else if (pipeDistance > 80) {
                // Medium distance - start positioning but stay low
                
                // Only flap if below the ideal (lower) position
                if (birdY > idealY + 30) {
                    aiDebugInfo.action = 'mid-position';
                    return true;
                }
                
                // If falling fast toward bottom, tap the brakes
                if (birdY > gapBottom - 100 && birdVelocity > 5) {
                    aiDebugInfo.action = 'mid-falling-fast';
                    return true;
                }
                
                aiDebugInfo.action = 'mid-coast';
                return false;
                
            } else {
                // We're close to the pipe - precise control
                
                // Only flap if we're in the bottom 70% of the gap
                if (birdY > gapTop + (gapSize * 0.7)) {
                    aiDebugInfo.action = 'close-bottom-danger';
                    return true;
                }
                
                // Emergency bottom pipe
                if (birdY > gapBottom - 70) {
                    aiDebugInfo.action = 'EMERGENCY-bottom';
                    return true;
                }
                
                // If we're in a good position (top half) and not falling too fast, coast!
                if (birdY < gapCenter && birdVelocity < 5) {
                    aiDebugInfo.action = 'close-good-coast';
                    return false;
                }
                
                // If falling moderately in lower half, gentle correction
                if (birdY > gapCenter && birdVelocity > 3) {
                    aiDebugInfo.action = 'close-lower-correct';
                    return true;
                }
                
                aiDebugInfo.action = 'close-cruise';
                return false;
            }
            
            // This should rarely be hit now
            aiDebugInfo.action = 'fallthrough';
            return false;
        }
        
        // Stars for background
        const stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 2,
                opacity: Math.random() * 0.5 + 0.5
            });
        }
        
        // Initialize energy visualizer
        const energyViz = document.getElementById('energyVisualizer');
        const HEIGHT_BINS = 20;
        for (let i = 0; i < HEIGHT_BINS; i++) {
            const bar = document.createElement('div');
            bar.className = 'energy-bar';
            bar.id = `energy-bar-${i}`;
            energyViz.appendChild(bar);
        }
        
        /**
         * Update energy visualizer bars
         */
        function updateEnergyVisualizer() {
            if (!gameRunning) return;
            
            for (let i = 0; i < HEIGHT_BINS; i++) {
                const y = (i / HEIGHT_BINS) * canvas.height;
                const energy = calculateEnergy(y, 0, pipes, 0);
                
                // Map energy to color (blue = low, red = high)
                const normalizedEnergy = Math.min(energy / 10, 1);
                const hue = (1 - normalizedEnergy) * 240; // 240 = blue, 0 = red
                const color = `hsl(${hue}, 80%, 50%)`;
                
                const bar = document.getElementById(`energy-bar-${HEIGHT_BINS - 1 - i}`);
                if (bar) {
                    bar.style.backgroundColor = color;
                }
            }
        }
        
        function createPipe() {
            const minHeight = 100;
            
            // Progressive difficulty based on score
            let pipeGapSize = pipeGap;
            if (score < 5) {
                // Very easy - huge gap
                pipeGapSize = 280;
            } else if (score < 10) {
                // Easy - big gap
                pipeGapSize = 250;
            } else if (score < 20) {
                // Medium - normal gap
                pipeGapSize = 220;
            } else {
                // Hard - smaller gap
                pipeGapSize = 200;
            }
            
            const maxHeight = canvas.height - pipeGapSize - minHeight;
            
            // For first 5 pipes, keep them centered (easier to hit)
            let topHeight;
            if (score < 3) {
                // First 3 pipes - very centered
                const centerY = canvas.height / 2;
                topHeight = centerY - (pipeGapSize / 2);
            } else if (score < 5) {
                // Next 2 pipes - slightly random but still centered-ish
                const centerY = canvas.height / 2;
                const variance = 50;
                topHeight = centerY - (pipeGapSize / 2) + (Math.random() - 0.5) * variance;
            } else {
                // After score 5 - full randomness
                topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
            }
            
            pipes.push({
                x: canvas.width,
                topHeight: topHeight,
                bottomY: topHeight + pipeGapSize,
                passed: false
            });
        }
        
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a1128');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawPipes() {
            pipes.forEach(pipe => {
                const gradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipeWidth, 0);
                gradient.addColorStop(0, '#ff6b6b');
                gradient.addColorStop(0.5, '#ee5a6f');
                gradient.addColorStop(1, '#ff6b6b');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
                ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
                
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
                ctx.lineWidth = 4;
                ctx.strokeRect(pipe.x, 0, pipeWidth, pipe.topHeight);
                ctx.strokeRect(pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
            });
        }
        
        /**
         * Draw probability cloud (the cool quantum effect!)
         */
        function drawProbabilityCloud() {
            if (!gameRunning || probabilityCloud.length === 0 || !quantumMode) return;
            
            // Draw each sampled trajectory with transparency
            probabilityCloud.forEach((traj, idx) => {
                ctx.save();
                ctx.globalAlpha = 0.1;  // Very transparent
                
                // Color based on trajectory index (for variety)
                const hue = 40 + (idx / NUM_SAMPLES) * 40;  // Yellow to orange
                ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(birdX, birdY);
                
                traj.forEach((point, t) => {
                    const x = birdX + t * 3;  // Visualize forward in time
                    ctx.lineTo(x, point.y);
                });
                
                ctx.stroke();
                ctx.restore();
            });
            
            // Draw heatmap dots showing probability density
            const heatmapBins = 20;
            const binHeight = canvas.height / heatmapBins;
            const binCounts = new Array(heatmapBins).fill(0);
            
            // Count how many trajectories pass through each bin (in near future)
            probabilityCloud.forEach(traj => {
                for (let t = 0; t < Math.min(10, traj.length); t++) {
                    const bin = Math.floor((traj[t].y / canvas.height) * heatmapBins);
                    if (bin >= 0 && bin < heatmapBins) {
                        binCounts[bin]++;
                    }
                }
            });
            
            const maxCount = Math.max(...binCounts);
            binCounts.forEach((count, i) => {
                if (count > 0) {
                    const alpha = count / maxCount;
                    ctx.fillStyle = `rgba(255, 200, 100, ${alpha * 0.3})`;
                    ctx.fillRect(birdX + 40, i * binHeight, 60, binHeight);
                }
            });
        }
        
        function drawBird() {
            ctx.save();
            
            // Show AI debug info
            if (autoplayMode && gameRunning) {
                // Draw target line
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, aiDebugInfo.targetY);
                ctx.lineTo(canvas.width, aiDebugInfo.targetY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw AI action text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '14px Courier New';
                ctx.fillText(`AI: ${aiDebugInfo.action}`, 10, canvas.height - 10);
            }
            
            // Draw multi-burds if enabled
            if (multiBurdMode && multiBurds.length > 0) {
                multiBurds.forEach((burd, i) => {
                    drawSingleBird(burd.y, 0.3); // Draw with transparency
                });
            }
            
            // Draw main bird (always on top)
            drawSingleBird(birdY, 1.0);
            
            ctx.restore();
        }
        
        /**
         * Draw a single bird at given Y position
         */
        function drawSingleBird(y, alpha = 1.0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            
            // Outer glow
            const gradient = ctx.createRadialGradient(birdX, y, 0, birdX, y, birdSize * 1.5);
            gradient.addColorStop(0, 'rgba(255, 220, 100, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 180, 100, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 107, 107, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(birdX, y, birdSize * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner bird
            const birdGradient = ctx.createRadialGradient(birdX, y, 0, birdX, y, birdSize);
            birdGradient.addColorStop(0, '#ffeb3b');
            birdGradient.addColorStop(0.7, '#ffc107');
            birdGradient.addColorStop(1, '#ff9800');
            
            ctx.fillStyle = birdGradient;
            ctx.beginPath();
            ctx.arc(birdX, y, birdSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye (only on main bird)
            if (alpha === 1.0) {
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(birdX + 8, y - 5, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(birdX + 10, y - 7, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        /**
         * Draw optimal path (ghost trail)
         */
        function drawOptimalPath() {
            if (!showOptimalPath || !optimalPathData) return;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 255, 100, 0.6)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            
            ctx.beginPath();
            optimalPathData.forEach((point, i) => {
                if (i === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            ctx.stroke();
            
            // Draw ghost bird at end of path
            if (optimalPathData.length > 0) {
                const endPoint = optimalPathData[Math.min(frameCount % optimalPathData.length, optimalPathData.length - 1)];
                drawSingleBird(endPoint.y, 0.4);
            }
            
            ctx.setLineDash([]);
            ctx.restore();
        }
        
        function update() {
            if (!gameRunning) return;
            
            frameCount++;
            
            // Update energy visualizer
            if (frameCount % 5 === 0) {
                updateEnergyVisualizer();
            }
            
            // Update multi-burds
            if (multiBurdMode) {
                updateMultiBurds();
            }
            
            // AI autoplay decision - check EVERY frame for better responsiveness
            if (autoplayMode) {
                if (aiDecideFlap()) {
                    birdVelocity = flapPower;
                    if (quantumMode) {
                        sampleProbabilityCloud();
                    }
                }
            }
            
            // Sample probability cloud every 10 frames (if quantum mode on)
            if (quantumMode && frameCount % 10 === 0) {
                sampleProbabilityCloud();
            }
            
            // Bird physics
            birdVelocity += gravity;
            if (birdVelocity > maxFallSpeed) {
                birdVelocity = maxFallSpeed;
            }
            birdY += birdVelocity;
            
            if (frameCount > gracePeriod) {
                pipes.forEach(pipe => {
                    pipe.x -= pipeSpeed;
                    
                    if (!pipe.passed && pipe.x + pipeWidth < birdX) {
                        pipe.passed = true;
                        score++;
                        updateScoreDisplay();
                    }
                });
                
                pipes = pipes.filter(pipe => pipe.x > -pipeWidth);
                
                if ((frameCount - gracePeriod) % 120 === 0) {
                    createPipe();
                }
                
                checkCollisions();
            } else {
                if (birdY - birdSize < 0 || birdY + birdSize > canvas.height) {
                    gameOver();
                }
            }
        }
        
        function updateScoreDisplay() {
            const quantumText = quantumMode ? 'üåå' : '';
            const autoText = autoplayMode ? 'ü§ñ' : '';
            document.getElementById('info').textContent = `Score: ${score} ${quantumText} ${autoText}`;
        }
        
        function checkCollisions() {
            if (birdY - birdSize < 0 || birdY + birdSize > canvas.height) {
                gameOver();
                return;
            }
            
            pipes.forEach(pipe => {
                if (birdX + birdSize > pipe.x && birdX - birdSize < pipe.x + pipeWidth) {
                    if (birdY - birdSize < pipe.topHeight || birdY + birdSize > pipe.bottomY) {
                        gameOver();
                    }
                }
            });
        }
        
        function gameOver() {
            if (!gameRunning) return;  // Already game over
            gameRunning = false;
            gameOverTime = Date.now();
            
            // Calculate optimal path for replay
            optimalPathData = calculateOptimalPath();
            
            // Show optimal path button
            document.getElementById('optimalPathBtn').style.display = 'block';
        }
        
        function drawGameOverScreen() {
            const timeSinceGameOver = Date.now() - gameOverTime;
            
            // Show game over screen after delay
            if (timeSinceGameOver > GAME_OVER_DELAY) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 48px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', canvas.width/2, canvas.height/2 - 40);
                
                ctx.fillStyle = '#88ccff';
                ctx.font = '24px Courier New';
                ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 10);
                ctx.fillText('Click to Restart', canvas.width/2, canvas.height/2 + 50);
            } else {
                // During delay, show a small indicator
                const alpha = Math.min(timeSinceGameOver / GAME_OVER_DELAY, 0.5);
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = '32px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('COLLISION!', canvas.width/2, canvas.height/2);
            }
        }
        
        function flap() {
            if (!gameStarted) {
                startGame();
            } else if (!gameRunning) {
                // Only allow restart after delay has passed
                const timeSinceGameOver = Date.now() - gameOverTime;
                if (timeSinceGameOver > GAME_OVER_DELAY) {
                    restartGame();
                }
            } else {
                // Don't allow manual flapping in autoplay mode
                if (!autoplayMode) {
                    birdVelocity = flapPower;
                    // Re-sample immediately on flap for responsive feel
                    if (quantumMode) {
                        sampleProbabilityCloud();
                    }
                }
            }
        }
        
        function startGame() {
            gameStarted = true;
            gameRunning = true;
            if (quantumMode) {
                sampleProbabilityCloud();  // Initial sampling
            }
            updateScoreDisplay();
            document.getElementById('instructions').style.display = 'none';
        }
        
        function restartGame() {
            score = 0;
            birdY = 100;
            birdVelocity = 0;
            pipes = [];
            frameCount = 0;
            probabilityCloud = [];
            gameRunning = true;
            gameOverTime = 0;
            showOptimalPath = false;
            optimalPathData = null;
            document.getElementById('optimalPathBtn').style.display = 'none';
            if (quantumMode) {
                sampleProbabilityCloud();
            }
            if (multiBurdMode) {
                initializeMultiBurds();
            }
            updateScoreDisplay();
        }
        
        function gameLoop() {
            drawBackground();
            drawProbabilityCloud();  // Draw BEFORE pipes so trails go behind
            drawOptimalPath();       // Draw optimal path if showing
            drawPipes();
            drawBird();
            
            if (!gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 48px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Probabilistic Flappy Burd', canvas.width/2, canvas.height/2 - 60);
                
                ctx.fillStyle = '#88ccff';
                ctx.font = '24px Courier New';
                ctx.fillText('Click or Press Space to Start', canvas.width/2, canvas.height/2 + 20);
                
                ctx.font = '18px Courier New';
                ctx.fillStyle = '#ffeb3b';
                ctx.fillText('Or enable Autoplay and watch the AI!', canvas.width/2, canvas.height/2 + 60);
            } else if (!gameRunning) {
                // Game over state
                drawGameOverScreen();
            }
            
            update();
            requestAnimationFrame(gameLoop);
        }
        
        canvas.addEventListener('click', flap);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                flap();
            }
        });
        
        gameLoop();
    </script>
</body>
</html>
